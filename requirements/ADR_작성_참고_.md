## Architecture Decision Record (ADR) 작성 예시

요구사항을 기반으로 E-커머스 상품 주문 서비스의 **서버 설계**를 위한 **ADR (Architecture Decision Record)** 작성 예시입니다. ADR은 특정 기술적 결정, 그 이유, 대안 등을 기록하여 팀원 간의 합의를 돕고 향후 히스토리 추적을 용이하게 합니다.

### ADR-001: 상품 잔여 수량 관리 및 동시성 제어 전략

| 메타데이터 | 내용 |
| :--- | :--- |
| **제목** | 상품 잔여 수량 관리 및 동시성 제어 전략 |
| **상태** | 결정 (Accepted) |
| **결정 일자** | 2025-10-21 (가정) |
| **작성자** | AI Assistant (예시) |

#### 1. 배경 및 문제 정의

E-커머스 서비스에서 **상품 조회 시점의 정확한 잔여 수량** 제공 및 **주문/결제 시점의 재고 차감 동시성 이슈**를 해결해야 합니다. 다수의 인스턴스로 애플리케이션이 동작하더라도 재고 관리의 무결성이 보장되어야 합니다.

#### 2. 결정 사항

**재고 관리에는 RDBMS를 사용하되, 잔여 수량 차감 시에는 Pessimistic Lock (비관적 잠금) 또는 Transaction Isolation Level 조정을 활용합니다.**

**세부 내용:**

1.  **상품 정보 저장:** 상품 ID, 이름, 가격, **잔여 수량**은 **RDBMS (예: PostgreSQL, MySQL)** 에 저장합니다. RDBMS의 트랜잭션 및 무결성 제약 조건을 활용하여 데이터 정합성을 확보합니다.
2.  **상품 조회 시 잔여 수량:** 일반 조회 API (`GET /products/{productId}`)는 RDBMS에서 직접 조회하여 **최대한 정확한** 실시간 잔여 수량을 제공합니다. (단, 대규모 트래픽 발생 시, 이 조회 API에 대해서는 캐싱을 고려할 수 있으나, 주문 시점의 재고는 RDBMS를 사용합니다.)
3.  **주문 시 재고 차감 동시성 제어:**
    * **옵션 1 (선택): 비관적 잠금 (Pessimistic Lock)**: 주문/결제 트랜잭션 시작 시, 해당 상품의 재고 레코드에 **`SELECT FOR UPDATE`**를 적용하여 트랜잭션이 완료될 때까지 다른 트랜잭션의 접근 및 수정으로부터 보호합니다. 이는 재고 무결성을 강력하게 보장하지만, 락(Lock) 경합이 심할 경우 처리량이 감소할 수 있습니다.
    * **옵션 2 (대안): 낙관적 잠금 (Optimistic Lock)**: 재고 테이블에 **`version`** 컬럼을 추가하고, 재고 차감 시 버전 정보를 비교하여 업데이트합니다. 버전 불일치 시 재시도 로직이 필요하며, 구현이 더 복잡해질 수 있으나 락 경합으로 인한 지연은 줄어듭니다.
    * **결정:** **비관적 잠금 (Pessimistic Lock)**을 초기 구현에 채택하여 재고의 **무결성**을 최우선으로 확보합니다.

#### 3. 대안 (Alternatives)

| 대안 | 장점 | 단점 |
| :--- | :--- | :--- |
| **Redis를 사용한 재고 관리** | 매우 빠른 읽기/쓰기 속도, 높은 처리량. | 데이터 영속성 및 트랜잭션 보장 구현이 복잡해짐. 데이터 불일치 가능성 증가. |
| **RDBMS + Optimistic Lock** | 락 경합 시간을 줄일 수 있음. | 버전 관리 로직 구현 필요, 재시도 로직 필요. 재고 차감 실패 시 사용자 경험 저하 가능. |

#### 4. 근거 (Consequences)

* **장점:** RDBMS의 강력한 트랜잭션 및 잠금 기능을 활용하여 다수의 인스턴스 환경에서도 주문/결제 시 **재고 차감의 정확성과 무결성**을 보장합니다.
* **단점:** `SELECT FOR UPDATE` 사용으로 인해 동시 주문이 집중될 경우, DB 락 경합(Lock Contention)이 발생하여 **전체적인 주문 처리 속도가 저하**될 수 있습니다. 추후 성능 병목이 발생하면 Redis나 낙관적 잠금 방식으로 전환을 고려해야 합니다.

***

### ADR-002: 포인트 충전/조회 및 주문/결제 트랜잭션 전략

| 메타데이터 | 내용 |
| :--- | :--- |
| **제목** | 포인트 충전/조회 및 주문/결제 트랜잭션 전략 |
| **상태** | 결정 (Accepted) |
| **결정 일자** | 2025-10-21 (가정) |
| **작성자** | AI Assistant (예시) |

#### 1. 배경 및 문제 정의

주문/결제 시 **사용자 잔액 차감**은 **재고 차감**과 함께 **하나의 원자적인 트랜잭션**으로 처리되어야 합니다. 또한, 포인트 충전 시 잔액 업데이트에도 동시성 이슈를 고려해야 합니다.

#### 2. 결정 사항

**포인트 잔액 관리 및 모든 결제/충전 로직은 RDBMS를 사용하며, 동시성 제어를 위해 비관적 잠금 (Pessimistic Lock)을 활용합니다.**

**세부 내용:**

1.  **포인트 잔액 관리:** 사용자 ID와 잔액을 포함하는 **`UserPoint`** 테이블을 RDBMS에 유지합니다.
2.  **포인트 충전/차감 동시성 제어:**
    * **충전 API (`POST /points/charge`)** 및 **결제 API의 잔액 차감** 로직 모두, 해당 사용자(`userId`)의 포인트 레코드를 업데이트하기 전에 **`SELECT FOR UPDATE`**를 사용하여 비관적 잠금을 적용합니다.
    * 이를 통해 동시에 여러 충전 또는 결제 시도가 발생하더라도 **잔액의 무결성**을 보장합니다.
3.  **주문/결제 트랜잭션 범위:**
    * 단일 RDBMS 트랜잭션 내에서 **재고 차감** (ADR-001) 및 **잔액 차감**을 모두 처리하여, 둘 중 하나라도 실패하면 전체 트랜잭션을 롤백(Rollback)하도록 합니다 (**ACID 보장**).

#### 3. 대안 (Alternatives)

| 대안 | 장점 | 단점 |
| :--- | :--- | :--- |
| **분산 트랜잭션 (Saga Pattern)** | 포인트 시스템과 주문 시스템을 별도의 Microservice로 분리 가능. | 구현 복잡도가 매우 높음. 롤백이 어려움 (보상 트랜잭션 필요). 초기 서비스 규모에는 과도함. |

#### 4. 근거 (Consequences)

* **장점:** 단일 RDBMS 트랜잭션 및 비관적 잠금을 통해 **잔액과 재고의 정합성**을 가장 확실하게 보장할 수 있습니다. 초기 단계에서 가장 안정적인 접근법입니다.
* **단점:** DB 부하가 증가하고, 잔액 차감 시 다른 트랜잭션이 대기하는 현상이 발생할 수 있습니다.

***

### ADR-003: 주문 정보 실시간 데이터 플랫폼 전송 전략

| 메타데이터 | 내용 |
| :--- | :--- |
| **제목** | 주문 정보 실시간 데이터 플랫폼 전송 전략 |
| **상태** | 결정 (Accepted) |
| **결정 일자** | 2025-10-21 (가정) |
| **작성자** | AI Assistant (예시) |

#### 1. 배경 및 문제 정의

결제 성공 시 **실시간**으로 주문 정보를 **데이터 플랫폼 (어플리케이션 외부)**에 전송하여 데이터 분석에 활용해야 합니다. 이 전송 과정이 주문/결제 트랜잭션의 성능에 영향을 주거나 실패해서는 안 됩니다.

#### 2. 결정 사항

**주문 정보 전송은 비동기 메시지 큐 (Asynchronous Message Queue)를 통해 처리하며, 결제 트랜잭션 완료 후 이벤트를 발행합니다.**

**세부 내용:**

1.  **기술 선택:** **Kafka**와 같은 **비동기 메시지 큐 (Message Queue, MQ)** 를 사용합니다. (또는 RabbitMQ, AWS SQS 등)
2.  **발행 시점:** 주문/결제 트랜잭션이 **DB에 커밋(Commit)된 직후**에 주문 정보를 담은 이벤트를 MQ의 특정 토픽으로 발행합니다.
3.  **전송 무결성 (Mock 처리):**
    * **실제 구현:** 주문 서비스는 트랜잭션 커밋 후 이벤트를 MQ에 발행하고, 데이터 플랫폼은 해당 MQ 토픽을 구독하여 데이터를 수집합니다.
    * **테스트/Mock 구현:** 주문 서비스 내부의 **`DataPlatformClient`**와 같은 모듈을 **Fake Module (Mock API)** 로 구현하여, 결제 성공 시 `sendOrderData(orderInfo)` 메서드를 호출하고, 단위 테스트에서 이 호출 여부를 검증합니다. (실제 MQ 대신 메모리 내 이벤트를 사용하거나, 테스트 시에는 Mocking 프레임워크를 사용)

#### 3. 대안 (Alternatives)

| 대안 | 장점 | 단점 |
| :--- | :--- | :--- |
| **결제 트랜잭션 내 동기 호출** | 가장 단순한 구현. | 데이터 플랫폼 장애가 주문/결제 트랜잭션 실패로 이어짐. 성능 저하. |
| **CDC (Change Data Capture)** | 애플리케이션 변경 없이 DB 변경을 감지. | 구현 복잡도가 높고, 실시간성이 낮을 수 있음. |

#### 4. 근거 (Consequences)

* **장점:** 비동기 MQ를 사용함으로써 데이터 플랫폼으로의 전송 실패가 **주문/결제 서비스의 핵심 트랜잭션에 영향을 주지 않습니다.** 높은 처리량과 안정적인 데이터 수집을 보장합니다.
* **단점:** MQ를 운영하기 위한 추가적인 인프라(Kafka Cluster 등)와 비용이 필요합니다. 이벤트의 순서 보장이나 At-Least-Once/Exactly-Once 처리에 대한 고려가 필요합니다.

***

### ADR-004: 선착순 쿠폰 발급 전략 (대규모 동시성 고려)

| 메타데이터 | 내용 |
| :--- | :--- |
| **제목** | 선착순 쿠폰 발급 전략 (대규모 동시성 고려) |
| **상태** | 결정 (Accepted) |
| **결정 일자** | 2025-10-21 (가정) |
| **작성자** | AI Assistant (예시) |

#### 1. 배경 및 문제 정의

**선착순**으로 제한된 수량의 쿠폰을 발급해야 합니다. 발급 시작 시점에 **극심한 동시성 트래픽**이 예상되며, 재고(쿠폰 수량) 차감의 **무결성**과 **처리 속도**를 동시에 확보해야 합니다.

#### 2. 결정 사항

**선착순 쿠폰 발급에는 Redis의 Atomic 연산 (원자적 연산)을 활용하여 발급 가능 여부를 판단하고 대기열 처리 기능을 활용합니다.**

**세부 내용:**

1.  **쿠폰 잔여 수량 관리:** 쿠폰 발급 전용 Redis에 쿠폰 잔여 수량을 **`INCR`/`DECR`** 연산이 가능한 자료구조 (예: 단순 카운터)로 관리합니다.
2.  **발급 로직:**
    * 사용자가 쿠폰 발급 요청 시, Redis의 **`DECR` (원자적 감소)** 명령어를 사용하여 잔여 수량을 1 감소시킵니다.
    * 감소 결과가 **0보다 크거나 같으면 (N-1 >= 0)** 발급 성공으로 판단하고, 이후 비동기적으로 RDBMS에 사용자별 쿠폰 발급 이력 (소유 쿠폰)을 저장합니다.
    * 감소 결과가 **음수이면** 선착순 마감으로 판단하고 발급 실패를 응답합니다.
3.  **대기열/Pre-queue (선택):** 대규모 트래픽을 서버 앞단에서 흡수하고 분산시키기 위해, **Redis를 이용한 큐(Queue) 또는 분산락 기반의 대기열 시스템**을 도입하여 동시 요청 수를 제한하고 순차적으로 처리하도록 합니다.

#### 3. 대안 (Alternatives)

| 대안 | 장점 | 단점 |
| :--- | :--- | :--- |
| **RDBMS + Pessimistic Lock** | 데이터 무결성은 보장. | 락 경합으로 인한 성능 병목 발생. 대규모 동시 요청 시 DB 부하 및 서비스 지연 심각. 선착순 기능에 적합하지 않음. |

#### 4. 근거 (Consequences)

* **장점:** Redis의 **높은 처리 속도**와 **원자적 연산**을 통해 극심한 동시성 환경에서도 쿠폰 재고의 무결성을 빠르게 지키면서 처리량을 극대화할 수 있습니다.
* **단점:** Redis 장애 발생 시 쿠폰 발급이 중단될 수 있습니다. Redis의 데이터를 RDBMS와 동기화하는 로직이 필요하며, 쿠폰 발급 이력 저장은 비동기적으로 처리되므로 데이터의 **일관성(Consistency)**이 일시적으로 낮아질 수 있습니다.

***

### ADR-005: 인기 판매 상품 조회 전략

| 메타데이터 | 내용 |
| :--- | :--- |
| **제목** | 인기 판매 상품 조회 전략 |
| **상태** | 결정 (Accepted) |
| **결정 일자** | 2025-10-21 (가정) |
| **작성자** | AI Assistant (예시) |

#### 1. 배경 및 문제 정의

최근 3일간 **가장 많이 팔린 상위 5개 상품**을 제공해야 합니다. 이 통계 정보는 **실시간으로 집계될 필요는 없지만**, 너무 오래된 데이터여서는 안 됩니다. 또한, 상품 조회 API에 대한 부하를 최소화해야 합니다.

#### 2. 결정 사항

**주문 데이터 기반의 비동기 배치 처리 (Batch Processing)를 통해 인기 상품 목록을 미리 집계하고 캐싱합니다.**

**세부 내용:**

1.  **집계 방식:**
    * 주문 정보는 **데이터 플랫폼** (ADR-003 참고) 또는 별도의 **분석용 DB/데이터 웨어하우스 (DWH)** 에 누적됩니다.
    * **배치 작업 (Batch Job)** (예: Spring Batch, Kubernetes CronJob 등)을 사용하여 **매일 새벽 시간** (예: 03:00)에 3일간의 주문 데이터를 분석하여 판매량 순위를 집계합니다.
2.  **저장 및 캐싱:**
    * 집계된 **상위 5개 상품 ID 목록**을 **Redis**에 **TTL(Time-To-Live)**을 설정하여 저장합니다. (예: 24시간 TTL 설정)
    * 상품 정보 (이름, 가격 등)는 목록 조회 시 Redis의 캐시 또는 RDBMS에서 조회하여 최종 응답을 구성합니다.
3.  **API 응답:** 인기 판매 상품 조회 API (`GET /products/popular`)는 RDBMS에 저장된 통계 테이블 또는 Redis 캐시에서 미리 계산된 데이터를 조회하여 응답합니다.

#### 3. 대안 (Alternatives)

| 대안 | 장점 | 단점 |
| :--- | :--- | :--- |
| **매 조회 시 RDBMS에서 계산** | 가장 실시간에 가까운 통계. | RDBMS에 높은 부하. 조회 속도가 느림. 서비스 운영에 악영향. |
| **MQ 이벤트 기반 실시간 스트리밍 처리** | 매우 실시간에 가까운 통계 가능. | Kafka Streams, Spark Streaming 등 복잡한 기술 스택과 운영 노하우 요구. 초기 단계에는 과도함. |

#### 4. 근거 (Consequences)

* **장점:** **인기 판매 상품 조회 API의 응답 속도가 매우 빠르며** (캐시된 데이터 조회), 메인 RDBMS의 트랜잭션 부하를 **배치 작업 시간**으로 분리하여 서비스의 안정성을 높입니다.
* **단점:** 통계 정보는 최대 24시간 정도 **지연된 데이터**일 수 있습니다. (배치 실행 주기에 따라) 하지만 '인기 상품'이라는 통계적 성격상 실시간성이 극도로 중요하지 않다고 판단하여 허용합니다.





네, 맞습니다. ADR (Architecture Decision Record)은 **간략한 내용만 적는 것이 아니라 세부적인 내용까지 모두 포함**해야 합니다. 📝

ADR의 목적은 특정 **기술적 결정**이 내려진 **맥락, 이유, 대안, 그리고 그 결정의 결과(장단점)**를 명확하고 완전하게 기록하는 것입니다.

### ADR에 세부적인 내용이 필요한 이유

1.  **배경 및 문제 정의 (Context):**
    * **무엇을 해결하려 했는지**에 대한 상세한 설명이 없으면, 나중에 문서를 보는 사람이 결정의 필요성을 이해하기 어렵습니다. 예를 들어, "재고 관리가 문제"라고만 적는 것이 아니라, "**다중 인스턴스 환경에서 동시 주문 시 잔여 수량의 무결성을 보장**"해야 한다는 구체적인 제약 사항을 명시해야 합니다.
2.  **결정 사항 (Decision):**
    * **어떤 기술/전략을 선택했는지**뿐만 아니라, 그 기술을 **어떻게 적용할 것인지**에 대한 **구체적인 구현 접근 방식**을 포함해야 합니다. (예: 단순히 RDBMS를 쓴다가 아니라, `SELECT FOR UPDATE` **비관적 잠금**을 사용한다고 명시)
3.  **대안 및 근거 (Alternatives & Consequences):**
    * **왜 다른 좋은 대안들을 기각했는지**에 대한 상세한 논리적 근거가 있어야 합니다. "Redis는 빠르지만, RDBMS의 무결성이 우선이다"와 같이 선택의 **트레이드오프**를 명확히 기록해야 후임자나 다른 팀원이 나중에 그 결정을 쉽게 뒤집지 않거나, 뒤집을 때 신중하게 고려할 수 있습니다.
4.  **역사 기록 (History):**
    * 시간이 지나 기술 환경이 바뀌었을 때, **과거의 결정이 왜 최선이었는지**를 상세한 기록을 통해 빠르게 파악하고 재평가할 수 있습니다.

따라서, 제가 앞서 제공해 드린 예시처럼 **메타데이터, 배경, 결정, 대안, 근거**의 모든 섹션을 채워서 상세히 작성해야 합니다.